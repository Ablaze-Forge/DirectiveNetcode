using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using AblazeForge.DirectiveNetcode.Messaging;
using AblazeForge.DirectiveNetcode.Messaging.MessageAttributes;
using Unity.Collections;
using UnityEditor;
using UnityEngine;

namespace AblazeForge.DirectiveNetcode.Editor.CodeGen
{
    /// <summary>
    /// Generates strongly-typed message deserializer methods based on methods 
    /// decorated with <see cref="CodeGenMessageAttribute"/> or <see cref="CodeGenControlMessageAttribute"/>.
    /// Produces a single auto-generated source file containing the deserializers.
    /// </summary>
    public static class MessageDeserializerSourceGenerator
    {
        /// <summary>
        /// Path where generated deserializer source files are written.
        /// </summary>
        private static readonly string OutputPath = Path.Combine("Assets", "Scripts", "Generated");

        /// <summary>
        /// Maps supported parameter types to the code string used to deserialize them from a <see cref="DataStreamReader"/>.
        /// </summary>
        private static Dictionary<Type, string> m_TypeDeserializerDictionary = new()
        {
            // Primitives
            { typeof(int),      "stream.ReadInt();" },
            { typeof(uint),     "stream.ReadUInt();" },
            { typeof(long),     "stream.ReadLong();" },
            { typeof(ulong),    "stream.ReadULong();" },
            { typeof(short),    "stream.ReadShort();" },
            { typeof(ushort),   "stream.ReadUShort();" },
            { typeof(byte),     "stream.ReadByte();" },
            { typeof(bool),     "stream.ReadBool();" },
            { typeof(float),    "stream.ReadFloat();" },
            { typeof(double),   "stream.ReadDouble();" },

            // Complex types
            { typeof(string),   "stream.ReadString().Value;" },
            { typeof(Vector2),  "stream.ReadVector2().Value;" },
            { typeof(DateTime), "stream.ReadDateTime().Value;"}

            // TODO: Add fixed length strings from UnityCollections
        };

        /// <summary>
        /// Entry point exposed in Unity's editor menu to generate deserializers.
        /// Scans loaded assemblies for methods decorated with message attributes and generates code accordingly.
        /// </summary>
        [MenuItem("Tools/CodeGen/Generate Message Deserializers")]
        public static void Run()
        {
            if (!Directory.Exists(OutputPath))
                Directory.CreateDirectory(OutputPath);

            var assemblies = AssemblyFilter.GetCandidateAssemblies();

            // Collect all candidate types, skipping assemblies that fail to load completely
            var types = assemblies
                .SelectMany(a =>
                {
                    try { return a.GetTypes(); }
                    catch (ReflectionTypeLoadException e) { return e.Types.Where(t => t != null); }
                });

            var diagnostics = new List<Diagnostic>();

            // Create the generated source file
            using (FileStream fileStream = File.Create(Path.Combine(OutputPath, "GeneratedMessageDeserializers.g.cs")))
            {
                using StreamWriter streamWriter = new(fileStream);
                using IndentedTextWriter writer = new(streamWriter);

                writer.WriteLine("// <auto-generated/>");

                // Add required usings
                writer.WriteLine();
                writer.WriteLine("using System;");
                writer.WriteLine("using Unity.Collections;");
                writer.WriteLine("using AblazeForge.DirectiveNetcode.Unity.Extensions;");
                writer.WriteLine("using AblazeForge.DirectiveNetcode.Messaging.MessageAttributes;");

                // Create the container class
                writer.WriteLine();
                writer.WriteLine("namespace AblazeForge.DirectiveNetcode.Messaging.Generated");
                writer.WriteLine("{");
                writer.Indent++;
                writer.WriteLine("public static class GeneratedMessageDeserializers");
                writer.WriteLine("{");
                writer.Indent++;

                // Scan methods for attributes
                foreach (var typeInfo in types)
                {
                    foreach (var method in typeInfo.GetMethods(
                        BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance))
                    {
                        var attributes = method.GetCustomAttributes(inherit: false);

                        var codeGenMessageAttribute = attributes.OfType<CodeGenMessageAttribute>().FirstOrDefault();
                        var codeGenControlMessageAttribute = attributes.OfType<CodeGenControlMessageAttribute>().FirstOrDefault();

                        if (codeGenMessageAttribute == null && codeGenControlMessageAttribute == null)
                            continue;

                        // Ensure methods are valid candidates (public static inside a public class)
                        if (!method.IsPublic || !method.IsStatic || !method.DeclaringType.IsPublic)
                        {
                            diagnostics.Add(new Diagnostic(
                                $"Method {method.DeclaringType.FullName}.{method.Name} must be public static and declared in a public class to use [CodeGenMessage] or [CodeGenControlMessage].",
                                method,
                                LogType.Error
                            ));
                            continue;
                        }

                        // Handle [CodeGenMessage]
                        if (codeGenMessageAttribute != null)
                        {
                            if (method.ReturnType == typeof(void))
                            {
                                WriteMessage(method, writer, codeGenMessageAttribute);
                            }
                            else
                            {
                                diagnostics.Add(new Diagnostic(
                                    $"[CodeGenMessage] on {method.DeclaringType.FullName}.{method.Name} should return {typeof(void).Name}.", method, LogType.Error
                                ));
                            }
                        }

                        // Handle [CodeGenControlMessage]
                        if (codeGenControlMessageAttribute != null)
                        {
                            if (method.ReturnType == typeof(bool))
                            {
                                WriteControlMessage(method, writer, codeGenControlMessageAttribute);
                            }
                            else
                            {
                                diagnostics.Add(new Diagnostic(
                                    $"[CodeGenControlMessage] on {method.DeclaringType.FullName}.{method.Name} should return {typeof(bool).Name}.", method, LogType.Error
                                ));
                            }
                        }
                    }
                }

                writer.Indent--;
                writer.WriteLine("}");
                writer.Indent--;
                writer.WriteLine("}");
            }

            // Log errors/warnings with clickable links in Unity console
            if (diagnostics.Count > 0)
            {
                UnityClickableLinkHelper.WarmupFileCache();
            }

            foreach (var diagnostic in diagnostics)
            {
                LogWithClickableLink(diagnostic.Message, diagnostic.Method, diagnostic.LogType);
            }

            diagnostics.Clear();
        }

        /// <summary>
        /// Emits a generated method marked with <see cref="MessageAttribute"/> that deserializes incoming data from the stream and then invokes the target user-defined method decorated with [CodeGenMessage].
        /// </summary>
        private static void WriteMessage(MethodInfo method, IndentedTextWriter writer, CodeGenMessageAttribute attribute)
        {
            writer.WriteLine($"[Message({attribute.MessageKey}, {nameof(MessageSide)}.{attribute.MessageSide}, {attribute.RequiredConnectionFlags})]");
            writer.Write("public static void ");
            WriteMethod(method, writer);
        }

        /// <summary>
        /// Emits a generated method marked with <see cref="ControlMessageAttribute"/> that deserializes incoming data from the stream and then invokes the target user-defined method decorated with [CodeGenMessage].
        /// </summary>
        private static void WriteControlMessage(MethodInfo method, IndentedTextWriter writer, CodeGenControlMessageAttribute attribute)
        {
            writer.WriteLine($"[ControlMessage({attribute.MessageKey}, {nameof(MessageSide)}.{attribute.MessageSide}, {attribute.RequiredConnectionFlags})]");
            writer.Write("public static bool ");
            WriteMethod(method, writer);
        }

        /// <summary>
        /// Writes the core deserializer method body that declares deserialized parameters and then invokes the target user-defined method with those parameters.
        /// </summary>
        private static void WriteMethod(MethodInfo method, IndentedTextWriter writer)
        {
            string safeMethodName = method.DeclaringType.FullName
                .Replace(".", "_")
                .Replace("+", "_");
            safeMethodName += "_" + method.Name;

            writer.Write(safeMethodName);

            writer.WriteLine($" ({nameof(UInt64)} connectionUID, {nameof(MessageMetadataHandler)} messageMetadata, {nameof(DataStreamReader)} stream)");
            writer.WriteLine("{");
            writer.Indent++;

            var parameters = method.GetParameters();

            for (int i = 0; i < parameters.Length; i++)
            {
                var param = parameters[i];
                var paramType = param.ParameterType;

                if (param.Name == "connectionUID" || param.Name == "messageMetadata")
                {
                    continue;
                }

                if (m_TypeDeserializerDictionary.TryGetValue(paramType, out string text))
                {
                    writer.WriteLine($"{paramType.Name} {param.Name} = {text}");
                }
                else
                {
                    throw new NotImplementedException($"No type deserializer string added for type {paramType.Name}.");
                }
            }

            string args = string.Join(", ", parameters.Select(p => p.Name));
            writer.WriteLine($"{method.DeclaringType.FullName}.{method.Name}({args});");

            writer.Indent--;
            writer.WriteLine("}");
        }

        /// <summary>
        /// Logs a diagnostic with a clickable link to the offending method in Unity's console.
        /// </summary>
        private static void LogWithClickableLink(string message, MethodInfo method, LogType logType = LogType.Error)
        {
            string link = UnityClickableLinkHelper.GetUnityClickableLink(method);
            string finalMessage = $"{message}{Environment.NewLine}Location: {link}";

            switch (logType)
            {
                case LogType.Warning:
                    Debug.LogWarning(finalMessage);
                    break;
                case LogType.Log:
                    Debug.Log(finalMessage);
                    break;
                default:
                    Debug.LogError(finalMessage);
                    break;
            }
        }

        /// <summary>
        /// Represents a single diagnostic (error or warning) encountered during code generation.
        /// </summary>
        private record Diagnostic
        {
            public readonly string Message;
            public readonly MethodInfo Method;
            public readonly LogType LogType;

            public Diagnostic(string message, MethodInfo method, LogType logType)
            {
                Message = message;
                Method = method;
                LogType = logType;
            }
        }
    }

    /// <summary>
    /// Filters assemblies to exclude system, Unity, and common third-party libraries.
    /// Used to find only user/game assemblies for code generation.
    /// </summary>
    internal static class AssemblyFilter
    {
        private static readonly string[] AssemblyBlacklistPrefixes =
        {
            "System",
            "Microsoft",
            "mscorlib",
            "netstandard",
            "Unity",
            "Mono.",
            "Newtonsoft",
            "nunit",
            "xunit",
            "JetBrains",
            "Roslyn",
            "Accessibility"
        };

        /// <summary>
        /// Gets assemblies that are likely candidates for scanning user-defined message handlers.
        /// Excludes assemblies whose names start with one of the blacklisted prefixes.
        /// </summary>
        public static IEnumerable<Assembly> GetCandidateAssemblies()
        {
            var allAssemblies = AppDomain.CurrentDomain.GetAssemblies();

            var candidates = allAssemblies
                .Where(a =>
                {
                    var name = a.FullName;
                    foreach (var prefix in AssemblyBlacklistPrefixes)
                    {
                        if (name.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))
                            return false;
                    }
                    return true;
                })
                .ToList();

            return candidates;
        }
    }
}
